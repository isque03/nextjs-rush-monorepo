# Next.js + Shared Library Monorepo (Rush.js Starter)

This repository is a minimal example of using [Rush.js](https://rushjs.io) to manage a monorepo that contains:
- a **Next.js** web application
- a **shared TypeScript + React library**

It is intended for developers with basic experience in TypeScript and React, but who may have no prior experience with Rush or monorepos.

---

## Prerequisites

Before getting started, ensure you have:

- **Node.js** >=22.20.0 <23.0.0 (check with `node --version`)
  - If you need to install or switch Node versions, consider using [nvm](https://github.com/nvm-sh/nvm) or [nvs](https://github.com/jasongin/nvs)
- **Rush.js** (optional - Rush can be run via local scripts in `common/scripts/`)
  - To install globally: `npm install -g @microsoft/rush`
  - Or use the local scripts: `node common/scripts/install-run-rush.js <command>`

---

## Repository Structure

```
monorepo/
├── apps/
│   └── web-app/             # The Next.js application
│       ├── src/
│       ├── next.config.ts   # Next.js configuration for monorepo
│       └── package.json
├── libraries/
│   └── shared-lib/          # Shared React components and utilities
│       ├── src/
│       ├── dist/            # Build output generated by TypeScript
│       └── package.json
├── rush.json                # Rush configuration defining the projects
├── common/
│   ├── config/rush/         # Rush-managed configuration and lockfiles
│   ├── temp/                # Rush-generated files (including pnpm-workspace.yaml)
│   └── scripts/             # Rush installation scripts
```

**Note:** The `pnpm-workspace.yaml` file is automatically generated by Rush in `common/temp/` during `rush update`. You don't need to create or modify it manually.

---

## What Rush Does

Rush.js is a monorepo manager that coordinates dependency installation and builds across multiple projects.

In this repository, Rush manages:
1. **Dependency installation** using PNPM (with a fixed version controlled by Rush)
2. **Linking local projects** together (e.g., `web-app` depends on `shared-lib`)
3. **Running build commands** in the correct dependency order
4. **Keeping a single lockfile** for all projects under `common/config/rush`

You can think of Rush as a controller that ensures all packages in the monorepo stay in sync and build correctly.

### Understanding `rush` vs `rushx`

- **`rush <command>`**: Runs Rush commands that operate on the entire monorepo (e.g., `rush build`, `rush update`)
- **`rushx <script>`**: Runs npm scripts defined in a project's `package.json` with the correct local dependencies linked. Always run this from within a project directory (e.g., `cd apps/web-app && rushx dev`)

---

## Setup

### 1. Install Dependencies

From the repository root:

```bash
rush update
```

This command:
- Installs all dependencies using a fixed PNPM version controlled by Rush
- Links the local packages together based on their dependencies
- Generates a consistent `node_modules` layout across the entire monorepo
- Creates the `pnpm-workspace.yaml` file in `common/temp/`

**Important:** You do **not** run `pnpm install` or `npm install` directly. Always use `rush update`.

### Understanding the `workspace:*` Protocol

In `apps/web-app/package.json`, you'll see:

```json
"dependencies": {
  "@myorg/shared-lib": "workspace:*"
}
```

The `workspace:*` protocol tells PNPM/Rush to link the local `shared-lib` package instead of installing it from npm. This ensures that:
- Changes to `shared-lib` are immediately available to `web-app`
- You're always working with the local version, not a published one
- Rush can manage the linking automatically

---

## Building Projects

### Build All Projects

To build all projects in dependency order:

```bash
rush build
```

Rush will detect that `web-app` depends on `shared-lib` and will build `shared-lib` first.

### Build a Specific Project

If you only want to build the shared library:

```bash
rush build --to @myorg/shared-lib
```

Each project's build command is defined in its `package.json` under the `scripts.build` field. For `shared-lib`, this runs `tsc --build`, which outputs compiled JavaScript and type definitions into the `dist/` folder.

---

## Development Workflow

### Running the Next.js Application

After the initial setup, you can start the Next.js app using:

```bash
cd apps/web-app
rushx dev
```

By default, the app runs on http://localhost:3000.

### Making Changes to the Shared Library

To see changes in `shared-lib` reflected in `web-app` during development, you have three options:

#### Option 1: Hot Reload (Recommended for Development)

This project is configured to allow Next.js to hot reload changes from the `@myorg/shared-lib` dependency during development. This enables a seamless development experience where changes to the shared library are immediately reflected in the web app **without requiring a rebuild**.

**How it works:**

The setup uses Next.js's ability to compile local packages from source, treating the shared library as part of the app source code.

1. **Configure shared-lib exports to expose source for bundlers**

   In `libraries/shared-lib/package.json`, the `exports` field is configured to expose the source TypeScript files for bundlers while maintaining compatibility with compiled output:

   ```json
   {
     "name": "@myorg/shared-lib",
     "version": "0.1.0",
     "main": "dist/index.js",
     "types": "dist/index.d.ts",
     "exports": {
       ".": {
         "types": "./dist/index.d.ts",
         "import": "./src/index.ts",
         "require": "./dist/index.js"
       }
     }
   }
   ```

   **Key points:**
   - Node/CommonJS consumers still get `dist/index.js`.
   - Modern bundlers (like Next with Turbopack) using `"import"` condition will read from `src/index.ts`.
   - Types still come from `dist/index.d.ts`.

2. **Tell Next to transpile this package**

   In `apps/web-app/next.config.ts`:

   ```typescript
   const nextConfig = {
     turbopack: {
       root: '../../'   // Points 2 levels up to the monorepo root
       // Or use absolute path: root: "/path/to/monorepo"
     },
     transpilePackages: ["@myorg/shared-lib"]
   };
   ```

   This ensures that:
   - Next.js watches the source files in `libraries/shared-lib/src/`
   - Changes trigger hot module reloading
   - TypeScript is transpiled on-the-fly during development

**Benefits:**
-  Instant hot reload when editing shared library code
-  No need to rebuild `shared-lib` during development
-  TypeScript types work correctly
-  Production builds still use optimized compiled output

**Hot Reload Development Workflow:**
1. Update dependencies: `rush update`
2. Start the Next.js dev server: `cd apps/web-app && rushx dev`
3. Edit `libraries/shared-lib/src/SharedComponent.tsx` (or any file in the shared library)
4. Save - Next should pick it up instantly (no manual `rush build` needed)

#### Option 2: Watch Mode

Run the shared library in watch mode so it rebuilds automatically:

1. In one terminal, start the watch mode:
   ```bash
   cd libraries/shared-lib
   rushx watch
   ```

2. In another terminal, start the Next.js dev server:
   ```bash
   cd apps/web-app
   rushx dev
   ```

The watch mode will rebuild `shared-lib` automatically when files change, and Next.js will pick up the changes.

#### Option 3: Manual Rebuild

If you prefer manual control:

1. Make changes to files in `libraries/shared-lib/src/`
2. Rebuild the library:
   ```bash
   rush build --to @myorg/shared-lib
   ```
3. Next.js dev server should pick up the changes automatically

### Production Builds

For production builds, the shared library should still be built separately:

```bash
cd libraries/shared-lib
rushx build
```

Or build everything:

```bash
rush build
```

This ensures optimized compiled output is used in production while maintaining fast development iteration.

### Next.js Configuration for Monorepo

The `apps/web-app/next.config.ts` file includes special configuration for monorepo support:

```typescript
const nextConfig = {
  turbopack: {
    root: '../../'   // Points 2 levels up to the monorepo root
    // Or use absolute path: root: "/path/to/monorepo"
  },
  transpilePackages: ["@myorg/shared-lib"]
};
```

This configuration ensures that:
- Next.js (when using Turbopack) correctly resolves modules from the monorepo structure
- The shared library is transpiled from source for hot reload support
- Proper module resolution of the shared library

---

## Working with the Shared Library

The shared library (`libraries/shared-lib`) is a standard TypeScript + React package that can be imported into the Next.js app.

### Example Structure

```typescript
// libraries/shared-lib/src/SharedComponent.tsx
import React from "react";

export function SharedComponent() {
  return <div>Hello from SharedComponent!</div>;
}

// libraries/shared-lib/src/index.ts
export * from "./SharedComponent";
```

The `web-app` can import it like this:

```typescript
import { SharedComponent } from "@myorg/shared-lib";

export default function Page() {
  return (
    <div>
      <h1>Web App</h1>
      <SharedComponent />
    </div>
  );
}
```

---

## TypeScript Configuration Notes

### shared-lib/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "jsx": "react-jsx",
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "lib": ["DOM", "ESNext"],
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

This configuration ensures TypeScript generates compiled files and `.d.ts` type definitions in `dist/`.

---

## Common Rush Commands

| Command | Description |
|---------|-------------|
| `rush update` | Install and link dependencies across all projects |
| `rush build` | Build all projects in dependency order |
| `rush build --to <project>` | Build a specific project and its dependencies |
| `rush rebuild` | Clean and rebuild all projects (more thorough than `rush build`) |
| `rushx <script>` | Run a script from a project's `package.json` using the correct environment |
| `rush list` | Show all projects and their dependency relationships |

---

## How Everything Fits Together

1. **Rush detects the project structure** from `rush.json`
2. **`rush update`** installs dependencies and links local packages (e.g., `@myorg/shared-lib`)
3. **`rush build`** compiles each project, starting with dependencies first
4. **`rushx dev`** runs the Next.js app in development mode
5. **Hot reload configuration** allows instant updates when editing `shared-lib` source files
6. **The app imports and uses components** from the shared library, demonstrating local workspace linking

---

## Troubleshooting

### Module Not Found Errors

**Error:** `Module not found: Can't resolve '@myorg/shared-lib'`

**Solutions:**
- Ensure you've run `rush update` to link packages
- Verify the library's `dist/` folder exists (run `rush build --to @myorg/shared-lib` if needed)
- Check that the package name in `libraries/shared-lib/package.json` matches the import (`@myorg/shared-lib`)
- For hot reload to work, ensure `next.config.ts` has `transpilePackages: ["@myorg/shared-lib"]`

### Hot Reload Not Working

**Problem:** Changes to `shared-lib` don't appear in the browser

**Solutions:**
- Verify `next.config.ts` includes `transpilePackages: ["@myorg/shared-lib"]`
- Check that `shared-lib/package.json` has `"import": "./src/index.ts"` in the exports field
- Ensure the `turbopack.root` path in `next.config.ts` is correct (relative path `'../../'` or absolute path to monorepo root)
- Restart the Next.js dev server: `rushx dev`

### TypeScript Errors

**Error:** TypeScript errors mentioning `JSX.IntrinsicElements`

**Solution:** Confirm the shared library's `tsconfig.json` includes:
- `"lib": ["DOM", "ESNext"]`
- `"jsx": "react-jsx"`

### Node Version Mismatch

**Error:** `Rush requires Node.js version >=22.20.0 <23.0.0`

**Solution:**
- Check your Node version: `node --version`
- Install or switch to the correct version using `nvm` or `nvs`
- Example with nvm: `nvm install 22.20.0 && nvm use 22.20.0`

### Accidental Manual Package Installation

**Problem:** You accidentally ran `pnpm install` or `npm install` directly

**Solution:**
- Delete any `node_modules` folders you created
- Run `rush update` again to restore Rush's managed state

### Lockfile Conflicts

**Error:** Lockfile conflicts or inconsistencies

**Solution:**
- Delete `common/temp/pnpm-lock.yaml` and `common/temp/node_modules`
- Run `rush update` to regenerate the lockfile

### Build Failures

**Problem:** Build fails with dependency errors

**Solution:**
- Run `rush update` to ensure all dependencies are installed and linked
- Try `rush rebuild` for a clean build
- Check that all projects are listed correctly in `rush.json`

---

## Adding New Projects

To add a new project to the monorepo:

1. **Create the project folder** in the appropriate category (`apps/` or `libraries/`)

2. **Add the project to `rush.json`**:
   ```json
   {
     "packageName": "@myorg/my-new-project",
     "projectFolder": "apps/my-new-project"
   }
   ```

3. **Create a `package.json`** in the new project folder with the matching `name` field

4. **Run `rush update`** to link the new project

5. **Add build scripts** to the project's `package.json` as needed

---

## Summary

- **Rush** manages dependency installation, linking, and build orchestration
- **PNPM** is used under the hood for efficient workspace dependency management
- **Next.js** provides the web application framework
- **Shared-lib** is a TypeScript React component library built and consumed locally
- The `workspace:*` protocol enables seamless local package linking
- **Hot reload** allows instant updates when editing shared library source files during development
- **Watch mode** provides an alternative development workflow with automatic rebuilds
- Production builds use optimized compiled output from `dist/`

This starter serves as a clear example of how to organize a scalable monorepo where multiple applications and shared libraries can grow under a single consistent build system with fast development iteration.
